<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dama - Jogo de Damas Brasileiras</title>
    <style>
        :root {
            --bg: #0a0a0f;
            --s1: #12121a;
            --s2: #1a1a24;
            --b1: rgba(255, 255, 255, .08);
            --t1: #f5f5f7;
            --t2: #8888a0;
            --t3: #555568;
            --ac: #ff6b35;
            --ac2: #ff8f65;
            --ok: #34d399;
            --err: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg);
            color: var(--t1);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 12px;
            gap: 12px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background-color: var(--s1);
            border-radius: 12px;
            font-size: 14px;
            gap: 12px;
        }

        #g-status {
            color: var(--ac);
            font-weight: 600;
            flex: 1;
            text-align: center;
        }

        #g-score {
            color: var(--t2);
            font-size: 13px;
            background-color: var(--s2);
            padding: 6px 12px;
            border-radius: 8px;
        }

        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
        }

        #board {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            background-color: var(--s1);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .5);
        }

        .cell {
            position: relative;
            cursor: pointer;
            user-select: none;
            -webkit-touch-callout: none;
        }

        .cell-dark {
            background-color: rgba(255, 255, 255, .08);
        }

        .cell-light {
            background-color: rgba(255, 255, 255, .04);
        }

        .cell.last-move {
            background-color: rgba(255, 107, 53, .15);
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: var(--ac);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.4;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.2; }
        }

        .piece {
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            top: 5%;
            left: 5%;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: transform 0.2s ease, filter 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, .4), inset -2px -2px 6px rgba(0, 0, 0, .3);
            touch-action: none;
        }

        .piece.p1 {
            background: linear-gradient(135deg, #ff8f65 0%, #ff6b35 100%);
            color: rgba(0, 0, 0, .2);
        }

        .piece.p2 {
            background: linear-gradient(135deg, #e8e8f0 0%, #d0d0d8 100%);
            color: rgba(0, 0, 0, .2);
        }

        .piece.selected {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--ac), 0 4px 12px rgba(0, 0, 0, .4), inset -2px -2px 6px rgba(0, 0, 0, .3);
        }

        .piece.captured {
            animation: captureAnim 0.4s ease-out forwards;
        }

        @keyframes captureAnim {
            to {
                opacity: 0;
                transform: scale(0.3);
            }
        }

        .crown {
            width: 50%;
            height: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        footer {
            display: flex;
            gap: 8px;
            justify-content: center;
            padding: 8px 0;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
            min-width: 44px;
            touch-action: manipulation;
        }

        .btn-primary {
            background-color: var(--ac);
            color: white;
            flex: 1;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--ac2);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(255, 107, 53, .3);
        }

        .btn-secondary {
            background-color: var(--s1);
            color: var(--t2);
            flex: 1;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--s2);
            color: var(--t1);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, .7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--s1);
            border-radius: 16px;
            padding: 32px 24px;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .6);
        }

        .modal-content h2 {
            margin-bottom: 8px;
            font-size: 24px;
            color: var(--t1);
        }

        .modal-content p {
            margin-bottom: 24px;
            color: var(--t2);
            font-size: 14px;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            flex-direction: column;
        }

        .modal-buttons button {
            padding: 12px 24px;
        }

        @media (max-width: 480px) {
            body {
                padding: 8px;
                gap: 8px;
            }

            header {
                padding: 10px 12px;
                font-size: 12px;
            }

            #board {
                max-width: 100%;
            }

            .modal-content {
                padding: 24px 16px;
            }
        }

        .ai-indicator {
            color: var(--t2);
            font-size: 12px;
            font-style: italic;
            padding: 4px 8px;
            background-color: var(--s2);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <div id="g-status">Sua vez</div>
        <div id="g-score">12 vs 12</div>
    </header>

    <div class="game-container">
        <div id="board"></div>
    </div>

    <footer>
        <button class="btn-secondary" id="btn-surrender">Desistir</button>
        <button class="btn-primary" id="btn-new-game">Novo Jogo</button>
    </footer>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Título</h2>
            <p id="modal-message">Mensagem</p>
            <div class="modal-buttons">
                <button class="btn-primary" id="modal-confirm">OK</button>
                <button class="btn-secondary" id="modal-cancel">Cancelar</button>
            </div>
        </div>
    </div>

    <script src="/games/core/bridge.js"></script>
    <script>
        // Game State
        const game = {
            board: [], // 8x8 board
            selectedPiece: null,
            validMoves: [],
            turn: 1, // 1 = player, 2 = opponent
            lastMove: null,
            gameMode: 'solo', // 'solo' or 'multiplayer'
            gameActive: true,
            forcedCaptures: [],
            p1Pieces: 12,
            p2Pieces: 12,
            aiThinking: false
        };

        // Initialize board
        function initBoard() {
            game.board = Array(8).fill(null).map(() => Array(8).fill(null));

            // Setup player 1 (orange) - bottom
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 === 1) {
                        game.board[r][c] = { player: 1, isKing: false };
                    }
                }
            }

            // Setup player 2 (white) - top
            for (let r = 5; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 === 1) {
                        game.board[r][c] = { player: 2, isKing: false };
                    }
                }
            }

            game.p1Pieces = 12;
            game.p2Pieces = 12;
        }

        // Render board
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell ' + ((r + c) % 2 === 1 ? 'cell-dark' : 'cell-light');
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // Check if last move
                    if (game.lastMove &&
                        ((game.lastMove.from[0] === r && game.lastMove.from[1] === c) ||
                         (game.lastMove.to[0] === r && game.lastMove.to[1] === c))) {
                        cell.classList.add('last-move');
                    }

                    // Check if valid move
                    if (game.validMoves.some(m => m[0] === r && m[1] === c)) {
                        cell.classList.add('valid-move');
                    }

                    // Add piece if exists
                    const piece = game.board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece p${piece.player}`;
                        if (game.selectedPiece && game.selectedPiece[0] === r && game.selectedPiece[1] === c) {
                            pieceEl.classList.add('selected');
                        }

                        // Add crown for king
                        if (piece.isKing) {
                            pieceEl.innerHTML = `
                                <svg class="crown" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 5l3 2 3-4 3 4 3-2 1 8H2l1-8z" fill="currentColor" opacity="0.6"/>
                                </svg>
                            `;
                        }

                        pieceEl.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (!game.gameActive || game.aiThinking) return;
                            selectPiece(r, c);
                        });

                        cell.appendChild(pieceEl);
                    }

                    cell.addEventListener('click', () => {
                        if (!game.gameActive || game.aiThinking) return;
                        if (game.validMoves.some(m => m[0] === r && m[1] === c)) {
                            movePiece(r, c);
                        }
                    });

                    boardEl.appendChild(cell);
                }
            }

            updateScore();
        }

        function selectPiece(r, c) {
            // Only allow selecting own pieces
            const piece = game.board[r][c];
            if (!piece || piece.player !== game.turn) {
                game.selectedPiece = null;
                game.validMoves = [];
                renderBoard();
                return;
            }

            game.selectedPiece = [r, c];
            game.validMoves = getValidMoves(r, c);
            renderBoard();
        }

        function getValidMoves(r, c) {
            const piece = game.board[r][c];
            if (!piece) return [];

            const moves = [];
            const directions = piece.isKing
                ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
                : piece.player === 1
                    ? [[1, -1], [1, 1]]
                    : [[-1, -1], [-1, 1]];

            // Check captures first (mandatory in Brazilian Checkers)
            const captures = getCaptureMoves(r, c);
            if (captures.length > 0) {
                return captures;
            }

            // Regular moves
            for (const [dr, dc] of directions) {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !game.board[nr][nc]) {
                    moves.push([nr, nc]);
                }
            }

            return moves;
        }

        function getCaptureMoves(r, c) {
            const piece = game.board[r][c];
            if (!piece) return [];

            const captures = [];
            const directions = piece.isKing
                ? [[-1, -1], [-1, 1], [1, -1], [1, 1]]
                : piece.player === 1
                    ? [[1, -1], [1, 1]]
                    : [[-1, -1], [-1, 1]];

            for (const [dr, dc] of directions) {
                const jr = r + dr;
                const jc = c + dc;
                const nr = r + dr * 2;
                const nc = c + dc * 2;

                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                    const jumped = game.board[jr][jc];
                    if (jumped && jumped.player !== piece.player && !game.board[nr][nc]) {
                        captures.push([nr, nc]);
                    }
                }
            }

            return captures;
        }

        function movePiece(toR, toC) {
            if (!game.selectedPiece) return;

            const [fromR, fromC] = game.selectedPiece;
            const piece = game.board[fromR][fromC];
            const captures = [];

            // Check if this is a capture move
            const jumpR = (fromR + toR) / 2;
            const jumpC = (fromC + toC) / 2;

            if (Math.abs(fromR - toR) === 2) {
                const jumped = game.board[jumpR][jumpC];
                if (jumped) {
                    game.board[jumpR][jumpC] = null;
                    captures.push([jumpR, jumpC]);
                    if (game.turn === 1) game.p2Pieces--;
                    else game.p1Pieces--;
                }
            }

            // Move piece
            game.board[toR][toC] = piece;
            game.board[fromR][fromC] = null;

            // Check for promotion
            if ((piece.player === 1 && toR === 7) || (piece.player === 2 && toR === 0)) {
                piece.isKing = true;
            }

            game.lastMove = { from: [fromR, fromC], to: [toR, toC] };
            game.selectedPiece = null;
            game.validMoves = [];

            // Check for additional captures
            if (captures.length > 0) {
                const additionalCaptures = getCaptureMoves(toR, toC);
                if (additionalCaptures.length > 0) {
                    // Must continue capturing
                    game.selectedPiece = [toR, toC];
                    game.validMoves = additionalCaptures;
                    renderBoard();
                    return;
                }
            }

            // Move successful, broadcast if multiplayer
            if (game.gameMode === 'multiplayer' && window.touchBridge) {
                touchBridge.broadcastMove({
                    from: [fromR, fromC],
                    to: [toR, toC],
                    captures: captures
                });
            }

            // Check game end
            if (game.p1Pieces === 0 || game.p2Pieces === 0) {
                endGame(game.p1Pieces === 0 ? 2 : 1);
                return;
            }

            // Switch turn
            game.turn = game.turn === 1 ? 2 : 1;
            updateStatus();
            renderBoard();

            // AI turn
            if (game.gameMode === 'solo' && game.turn === 2) {
                setTimeout(aiMove, 600);
            }
        }

        function aiMove() {
            if (!game.gameActive || game.turn !== 2) return;

            game.aiThinking = true;
            updateStatus();

            // Get all valid moves
            const validMoves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = game.board[r][c];
                    if (piece && piece.player === 2) {
                        const moves = getValidMoves(r, c);
                        for (const move of moves) {
                            const isCapture = Math.abs(r - move[0]) === 2;
                            validMoves.push({ from: [r, c], to: move, isCapture });
                        }
                    }
                }
            }

            // Prefer captures
            let bestMove = validMoves.find(m => m.isCapture) || validMoves[0];
            if (!bestMove) {
                // No valid moves - AI loses
                endGame(1);
                return;
            }

            game.selectedPiece = bestMove.from;
            movePiece(bestMove.to[0], bestMove.to[1]);
            game.aiThinking = false;
        }

        function updateStatus() {
            const statusEl = document.getElementById('g-status');
            if (game.gameActive) {
                if (game.aiThinking) {
                    statusEl.textContent = 'Oponente pensando...';
                } else {
                    statusEl.textContent = game.turn === 1 ? 'Sua vez' : 'Turno do oponente';
                }
            }
        }

        function updateScore() {
            const scoreEl = document.getElementById('g-score');
            scoreEl.textContent = `${game.p1Pieces} vs ${game.p2Pieces}`;
        }

        function endGame(winner) {
            game.gameActive = false;
            const message = winner === 1 ? 'Você venceu!' : 'Você perdeu!';

            if (game.gameMode === 'multiplayer' && window.touchBridge) {
                touchBridge.submitResult({ winner, result: message });
            }

            showModal(
                winner === 1 ? 'Vitória!' : 'Derrota',
                message,
                () => newGame(),
                'Novo Jogo'
            );
        }

        function newGame() {
            game.gameActive = true;
            game.selectedPiece = null;
            game.validMoves = [];
            game.turn = 1;
            game.lastMove = null;
            game.forcedCaptures = [];
            game.aiThinking = false;

            initBoard();
            updateStatus();
            renderBoard();
            closeModal();
        }

        function surrender() {
            if (!game.gameActive) return;

            showModal(
                'Desistir?',
                'Tem certeza que deseja desistir desta partida?',
                () => {
                    game.gameActive = false;
                    if (game.gameMode === 'multiplayer' && window.touchBridge) {
                        touchBridge.submitResult({ winner: 2, result: 'Você desistiu' });
                    }
                    endGame(2);
                },
                'Desistir',
                'Cancelar'
            );
        }

        function showModal(title, message, onConfirm, confirmText = 'OK', cancelText = 'Cancelar') {
            const modal = document.getElementById('modal');
            const titleEl = document.getElementById('modal-title');
            const messageEl = document.getElementById('modal-message');
            const confirmBtn = document.getElementById('modal-confirm');
            const cancelBtn = document.getElementById('modal-cancel');

            titleEl.textContent = title;
            messageEl.textContent = message;
            confirmBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;

            confirmBtn.onclick = () => {
                onConfirm();
                closeModal();
            };

            cancelBtn.onclick = closeModal;
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('modal').classList.remove('active');
        }

        // Event listeners
        document.getElementById('btn-new-game').addEventListener('click', newGame);
        document.getElementById('btn-surrender').addEventListener('click', surrender);

        // Handle opponent moves if multiplayer
        if (window.touchBridge && window.touchBridge.onOpponentMove) {
            touchBridge.onOpponentMove = (move) => {
                game.selectedPiece = move.from;
                movePiece(move.to[0], move.to[1]);
            };
        }

        // Initialize
        newGame();
    </script>
</body>
</html>
